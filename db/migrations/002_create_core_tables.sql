-- =========================
-- Create Core Tables
-- =========================

-- BOOKS / SOURCES
CREATE TABLE IF NOT EXISTS sources (
  id           INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  raw_text     TEXT,             -- raw text from the source
  book         TEXT NOT NULL,    -- e.g., "Core Rulebook"
  page         INT,              -- optional page number
  created_at   TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at   TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- TRADITIONS master list
CREATE TABLE IF NOT EXISTS traditions (
  id           INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name         TEXT NOT NULL UNIQUE,
  description  TEXT
);

-- TRAITS master list
CREATE TABLE IF NOT EXISTS traits (
  id           INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name         TEXT NOT NULL UNIQUE,
  description  TEXT
);

-- SPELLS
CREATE TABLE IF NOT EXISTS spells (
  id                INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name              TEXT NOT NULL,
  rank              INT  NOT NULL CHECK (rank BETWEEN 0 AND 10),
  spell_type        spell_type_enum  NOT NULL DEFAULT 'Spell',
  save_type         save_type_enum   NOT NULL DEFAULT 'None',
  rarity            rarity_type_enum NOT NULL DEFAULT 'Common',
  action_category   action_category_enum NOT NULL DEFAULT 'None',
  actions_min       SMALLINT,   -- used only when action_category = 'Activity'
  actions_max       SMALLINT,   -- used only when action_category = 'Activity'
  description       TEXT,
  source_id         INT REFERENCES sources(id) ON DELETE SET NULL,

  created_at        TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at        TIMESTAMPTZ NOT NULL DEFAULT NOW(),

  -- Enforce coherence between action_category and counts
  CONSTRAINT chk_actions_coherent CHECK (
    -- Activity: min/max present, in 1..3, and min <= max
    (action_category = 'Activity' AND actions_min IS NOT NULL AND actions_max IS NOT NULL
       AND actions_min BETWEEN 1 AND 3 AND actions_max BETWEEN 1 AND 3 AND actions_min <= actions_max)
    OR
    -- Free/Reaction: counts absent or 0
    (action_category IN ('Free','Reaction') AND (
        (actions_min IS NULL AND actions_max IS NULL)
        OR (actions_min = 0 AND actions_max = 0)
    ))
    OR
    -- None: no counts
    (action_category = 'None' AND actions_min IS NULL AND actions_max IS NULL)
  )
);

-- Many-to-many: spell ↔ tradition
CREATE TABLE IF NOT EXISTS spell_traditions (
  spell_id      INT NOT NULL REFERENCES spells(id)      ON DELETE CASCADE,
  tradition_id  INT NOT NULL REFERENCES traditions(id)  ON DELETE CASCADE,
  PRIMARY KEY (spell_id, tradition_id)
);

-- Many-to-many: spell ↔ trait
CREATE TABLE IF NOT EXISTS spell_traits (
  spell_id   INT NOT NULL REFERENCES spells(id) ON DELETE CASCADE,
  trait_id   INT NOT NULL REFERENCES traits(id) ON DELETE CASCADE,
  PRIMARY KEY (spell_id, trait_id)
);

-- Helper tables for CSV import (temporary)
CREATE TABLE IF NOT EXISTS spell_traits_helper (
  spell_name   TEXT NOT NULL,
  trait_name   TEXT NOT NULL
);

CREATE TABLE IF NOT EXISTS spell_traditions_helper (
  spell_name      TEXT NOT NULL,
  tradition_name  TEXT NOT NULL
);

-- =========================
-- Updated-at maintenance
-- =========================
CREATE OR REPLACE FUNCTION set_updated_at()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
BEGIN
  NEW.updated_at := NOW();
  RETURN NEW;
END;
$$;

DROP TRIGGER IF EXISTS trg_spells_updated_at ON spells;
CREATE TRIGGER trg_spells_updated_at
BEFORE UPDATE ON spells
FOR EACH ROW
EXECUTE FUNCTION set_updated_at();

DROP TRIGGER IF EXISTS trg_sources_updated_at ON sources;
CREATE TRIGGER trg_sources_updated_at
BEFORE UPDATE ON sources
FOR EACH ROW
EXECUTE FUNCTION set_updated_at();
